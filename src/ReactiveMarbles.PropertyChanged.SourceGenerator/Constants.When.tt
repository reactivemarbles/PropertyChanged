<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<# 
const int maxDepth = 12;
#>
// Copyright (c) 2019-<#=DateTime.Now.Year#> ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.
// <auto-generated />

using System;

namespace ReactiveMarbles.PropertyChanged.SourceGenerator
{
    internal static partial class Constants
    {
        internal const string WhenExtensionClassSource = @"
// Copyright (c) 2019-<#=DateTime.Now.Year#> ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.
// <auto-generated />

using System;
using System.ComponentModel;
using System.Linq.Expressions;
using System.Reactive.Concurrency;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Runtime.CompilerServices;

/// <summary>
/// Provides extension methods for the notify property changed extensions.
/// </summary>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[global::System.Diagnostics.DebuggerNonUserCode]
////[Preserve(AllMembers=true)]
[global::System.Reflection.Obfuscation(Exclude=true)]
[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
internal static partial class NotifyPropertyExtensions
{
    /// <summary>
    /// Notifies when the specified property changes.
    /// </summary>
    /// <param name=""objectToMonitor"">The object to monitor.</param>
    /// <param name=""propertyExpression"">The expression to the object.</param>
    /// <param name=""callerMemberName"">The caller of the method.</param>
    /// <param name=""callerFilePath"">The caller file path.</param>
    /// <param name=""callerLineNumber"">The caller line number.</param>
    /// <typeparam name=""TObj"">The type of initial object.</typeparam>
    /// <typeparam name=""TReturn"">The eventual return value.</typeparam>
    /// <returns>An observable that signals when the property specified in the expression has changed.</returns>
    public static IObservable<TReturn> WhenChanged<TObj, TReturn>(
        this TObj objectToMonitor, 
        Expression<Func<TObj, TReturn>> propertyExpression,
        [CallerMemberName]string callerMemberName = null,
        [CallerFilePath]string callerFilePath = null,
        [CallerLineNumber]int callerLineNumber = 0)
        where TObj : INotifyPropertyChanged
    {
        throw new Exception($""{callerMemberName} has no valid implementation for <{typeof(TObj).Name}, {typeof(TReturn).Name}> with property expression {propertyExpression.ToString()}."");
    }
<#
for (var depth = 2; depth <= maxDepth; depth++)
{
#>

    /// <summary>
    /// Notifies when the specified property changes.
    /// </summary>
    /// <param name=""objectToMonitor"">The object to monitor.</param>
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
    /// <param name=""propertyExpression<#= i #>"">A expression to the value<#= i #>.</param>
<#
    } 
#>
    /// <param name=""conversionFunc"">Parameter which converts into the end value.</param>
    /// <param name=""callerMemberName"">The caller of the method.</param>
    /// <param name=""callerFilePath"">The caller file path.</param>
    /// <param name=""callerLineNumber"">The caller line number.</param>
    /// <typeparam name=""TObj"">The type of initial object.</typeparam>
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
    /// <typeparam name=""TTempReturn<#= i #>"">The return type of the value<#= i #>.</typeparam>
<#
    }
#>
    /// <typeparam name=""TReturn"">The return value of the observable. Generated from the conversion func.</typeparam>
    /// <returns>An observable that signals when the properties specified in the expressions have changed.</returns>
<#
    var expressionReturn = string.Join(", ", Enumerable.Range(1, depth).Select(x => "TTempReturn" + x));
#>
    public static IObservable<TReturn> WhenChanged<TObj, <#= expressionReturn #>, TReturn>(
        this TObj objectToMonitor,
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
        Expression<Func<TObj, TTempReturn<#= i #>>> propertyExpression<#= i #>,
<#
    }
#>
        Func<<#= expressionReturn #>, TReturn> conversionFunc,
        [CallerMemberName]string callerMemberName = null,
        [CallerFilePath]string callerFilePath = null,
        [CallerLineNumber]int callerLineNumber = 0)
            where TObj : class, INotifyPropertyChanged
    {
        throw new Exception($""{callerMemberName} has no valid implementation for <{typeof(TObj).Name}, {typeof(TReturn).Name}>."");
    }
<#
}
#>

    /// <summary>
    /// Notifies when the specified property is about to change.
    /// </summary>
    /// <param name=""objectToMonitor"">The object to monitor.</param>
    /// <param name=""propertyExpression"">The expression to the object.</param>
    /// <param name=""callerMemberName"">The caller of the method.</param>
    /// <param name=""callerFilePath"">The caller file path.</param>
    /// <param name=""callerLineNumber"">The caller line number.</param>
    /// <typeparam name=""TObj"">The type of initial object.</typeparam>
    /// <typeparam name=""TReturn"">The eventual return value.</typeparam>
    /// <returns>An observable that signals when the property specified in the expression has is about to change.</returns>
    public static IObservable<TReturn> WhenChanging<TObj, TReturn>(
        this TObj objectToMonitor,
        Expression<Func<TObj, TReturn>> propertyExpression,
        [CallerMemberName]string callerMemberName = null,
        [CallerFilePath]string callerFilePath = null,
        [CallerLineNumber]int callerLineNumber = 0)
        where TObj : INotifyPropertyChanging
    {
        throw new Exception($""{callerMemberName} has no valid implementation for <{typeof(TObj).Name}, {typeof(TReturn).Name}>."");
    }
<#
for (var depth = 2; depth <= maxDepth; depth++)
{
#>

    /// <summary>
    /// Notifies when the specified property changes.
    /// </summary>
    /// <param name=""objectToMonitor"">The object to monitor.</param>
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
    /// <param name=""propertyExpression<#= i #>"">A expression to the value<#= i #>.</param>
<#
    } 
#>
    /// <param name=""conversionFunc"">Parameter which converts into the end value.</param>
    /// <param name=""callerMemberName"">The caller of the method.</param>
    /// <param name=""callerFilePath"">The caller file path.</param>
    /// <param name=""callerLineNumber"">The caller line number.</param>
    /// <typeparam name=""TObj"">The type of initial object.</typeparam>
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
    /// <typeparam name=""TTempReturn<#= i #>"">The return type of the value<#= i #>.</typeparam>
<#
    }
#>
    /// <typeparam name=""TReturn"">The return value of the observable. Generated from the conversion func.</typeparam>
    /// <returns>An observable that signals when the properties specified in the expressions are about to change.</returns>
<#
    var expressionReturn = string.Join(", ", Enumerable.Range(1, depth).Select(x => "TTempReturn" + x));
#>
    public static IObservable<TReturn> WhenChanging<TObj, <#= expressionReturn #>, TReturn>(
        this TObj objectToMonitor,
<#
    for (var i = 1; i <= depth; ++i)
    {
#>
        Expression<Func<TObj, TTempReturn<#= i #>>> propertyExpression<#= i #>,
<#
    }
#>
        Func<<#= expressionReturn #>, TReturn> conversionFunc,
        [CallerMemberName]string callerMemberName = null,
        [CallerFilePath]string callerFilePath = null,
        [CallerLineNumber]int callerLineNumber = 0)
            where TObj : class, INotifyPropertyChanging
    {
        throw new Exception($""{callerMemberName} has no valid implementation for <{typeof(TObj).Name}, {typeof(TReturn).Name}>."");
    }
<#
}
#>

    private static IObservable<T> GenerateWhenChangingObservable<TObj, T>(
            TObj parent,
            string memberName,
            Func<TObj, T> getter)
        where TObj : INotifyPropertyChanging
    {
        return Observable.Create<T>(
                observer =>
                {
                    PropertyChangingEventHandler handler = (object sender, PropertyChangingEventArgs e) =>
                    {
                        if (e.PropertyName == memberName)
                        {
                            observer.OnNext(getter(parent));
                        }
                    };

                    parent.PropertyChanging += handler;

                    return Disposable.Create((parent, handler), x => x.parent.PropertyChanging -= x.handler);
                })
            .StartWith(getter(parent));
    }

    private static IObservable<T> GenerateWhenChangedObservable<TObj, T>(
            TObj parent,
            string memberName,
            Func<TObj, T> getter)
        where TObj : INotifyPropertyChanged => Observable.Create<T>(
                observer =>
                {
                    PropertyChangedEventHandler handler = (object sender, PropertyChangedEventArgs e) =>
                    {
                        if (e.PropertyName == memberName)
                        {
                            observer.OnNext(getter(parent));
                        }
                    };

                    parent.PropertyChanged += handler;

                    return Disposable.Create((parent, handler), x => x.parent.PropertyChanged -= x.handler);
                })
            .StartWith(getter(parent));
    }
";
    }
}
